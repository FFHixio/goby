\chapter{Goby MOOS Modules}\label{chap:MOOS}
\MakeShortVerb{\!} % makes !foo! == !foo!

The acoustic communications portion of Goby was developed originally for the MOOS autonomy architecture. Thus, the relevant MOOS modules !pAcommsHandler! and others are still maintained (in goby/src/moos) for the use of the !MOOS-IvP! community. !MOOS-IvP! is explained in \cite{moos-ivp-jfr} and is available at \url{http://moos-ivp.org}. The usage of these modules is documented here. See \url{http://gobysoft.org/wiki/InstallingGoby} for how to install Goby.


\section{Goby MOOS Applications} \label{sec:goby_moos_app}

The Goby MOOS applications share a common subclass of CMOOSApp that provides a validating configuration reader based on the Google Protocol Buffers TextFormat class. The configuration is still embedded within the .moos file, but the syntax is somewhat different. Here you can control logging to a text file and terminal verbosity. You can also initialize a variable in the MOOS database at startup. Many of these parameters will automatically be set to a global MOOS variable (specified outside any ProcessConfig block) if left empty. For example, the global MOOS variable !LatOrigin! will set the Goby MOOS configuration variable !common::lat_origin!. This allows Goby MOOS applications to conform to MOOS \textit{de facto} conventions.

Any Goby MOOS application will give all its valid configuration parameters with \begin{verbatim}
> pGobyApp --example_config
\end{verbatim} 

\boxedverbatiminput{@RELATIVE_CMAKE_CURRENT_SOURCE_DIR@/includes/common.pb.cfg}
\resetbvlinenumber

Some details about the configuration values:

\begin{itemize}
\item !log!: boolean to indicate whether to log terminal output or not to files in the path by !log_path!.
\item !log_path!: folder to log all terminal output to for later debugging. Similar to system logs in /var/log.
\item !log_verbosity!: verbosity of the log file. See !verbosity! for the various settings.
\item !community!: the name of the current vehicle community. If omitted, read from the !Community=! global MOOS configuration field.
\item !lat_origin!: a decimal degrees latitude indicating the local cartesian origin. If omitted, read from the !LatOrigin=! global MOOS configuration field.
\item !lon_origin!: a decimal degrees longitude indicating the local cartesian origin. If omitted, read from the !LongOrigin=! global MOOS configuration field.
\item !app_tick!: same as AppTick.
\item !comm_tick!: same as CommsTick.
\item !verbosity!: choose !DEBUG1!-!DEBUG3! for various levels of debugging output, !VERBOSE! for some text terminal output, !WARN! for warnings only, and !QUIET! for no terminal output.
\item !show_gui!: if true, the running terminal opens an NCurses GUI helpful to debugging and visualizing the many data flows of pAcommsHandler. The verbosity in this GUI is governed by !verbosity!.
\item !initializer!: since many times it is useful to have a MOOS variable including in a message that remains static for a given mission (vehicle name, etc), we give the option to publish initial MOOS variables here (for later use in messages [until overwritten, of course]). If !global_cfg_var! is set, pAcommsHandler looks for a global (i.e. specified at the top of the MOOS file or outside any !ProcessConfig! blocks) value in the .moos file with the name to the right of the colon and publishes it to a MOOS variable with the name to the left of the colon. For example:
\begin{verbatim}
initializer { global_cfg_var: "LatOrigin" moos_var: "LAT_ORIGIN" } 
\end{verbatim}
\resetbvlinenumber
looks for a variable in the .moos file called !LatOrigin! and publishes it to the MOOSDB as a double variable !LAT_ORIGIN! with the value given by !LatOrigin!.
\end{itemize}


\section{pTranslator}
\label{sec:ptranslator} 

!pTranslator! is a translator between MOOS types (strings and doubles) and Google Protocol Buffers messages (which includes DCCL messages). All of the functionality of !pTranslator! is also present in !pAcommsHandler!, but !pTranslator! is provided as a standalone application for cases when Goby-Acomms is not needed, but the translation functionality is. Also, pTranslator loops back all created messages and immediately publishes them, whereas pAcommsHandler publishes messages received acoustically, and creates messages to be transmitted.

The configuration for !pTranslator! is as follows:

\boxedverbatiminput{@RELATIVE_CMAKE_CURRENT_SOURCE_DIR@/includes/pTranslator.moos}
\resetbvlinenumber

\begin{itemize}
\item !common!: Parameters that can be set for any of the Goby MOOS applications. See section \ref{sec:goby_moos_app}.
\item !load_shared_library!: Repeated string, each with a path to a shared library containing compiled DCCL (Google Protocol Buffers) messages.
\item !load_proto_file!: Repeated string, each with one path to a .proto file containing compiled DCCL (Google Protocol Buffers) messages. These will be compiled at runtime and loaded. It is preferable to use !load_shared_library! when possible, as syntactical and type mistakes in the DCCL messages will be caught at compile-time rather than delayed to runtime.
\item !translator_entry!: Repeated entry: there should be one !translator_entry! defined for each Google Protobuf message type that you wish to translate to or from.
\begin{itemize}
\item !protobuf_name!: Fully qualified name (packages separated by !.!, e.g. !example.MinimalStatus!) to the Protobuf message that this translator should use. This message must be loaded either by !load_shared_library! or !load_proto_file!. 
\item !trigger!: The event that causes this translation to occur.
\begin{itemize}
\item !type!: Either !TRIGGER_PUBLISH! (do a translation every time a given MOOS variable is published to) or !TRIGGER_TIME! (do a translation on a regular frequency).
\item !moos_var!: For !TRIGGER_PUBLISH!, the MOOS variable that causes the translation to occur.
\item !period!: For !TRIGGER_TIME!, the period (in seconds) between translations.
\item !mandatory_content!: For !TRIGGER_PUBLISH!, if this is defined, the !moos_var! must contain this substring in order to trigger this translation. Use of this field allows a single MOOS variable to trigger several different translations.
\end{itemize}
\item !create!: Upon triggering, this defines how the Protobuf message is created from one or more MOOS variables. Repeat this field for multiple MOOS variables. The !create! directives are processed in the order they are defined and thus later !create!s that write the same fields will overwrite earlier ones.
\begin{itemize}
\item !technique!: The parsing technique to use. See section \ref{sec:ptranslator_techniques}.
\item !moos_var!: The MOOS variable to use for this !create!. 
\item !format!: For !TECHNIQUE_FORMAT!, the format string to use. This is similar to scanf, but instead of type specifiers, numerical specifiers are used, surrounded by !%! on both sides. For example, if the !format! value is !foo=%1%!, this !create! will parse a !moos_var! containing !foo=5! and put the value !5! into field 1 of the Protobuf message given by !protobuf_name!. %
\item !repeated_delimiter!: When parsing for !repeated! Protobuf fields, this is the string that delimits fields. For example, if !foo=%1%!, field 1 is !repeated int32 field_name = 1!, and the value to parse is !foo=10;12;13;14!, !repeated_delimiter! should be ``;'' in order to parse these four numbers into a ``vector'' of values in that field. %
\item !algorithm!: An algorithm to modify the parsed field before placing it in the Protobuf message. These are largely provided for backwards compatibility for Goby v1, and are not necessarily encouraged for new use. See \url{http://gobysoft.com/dl/goby1-user-manual.pdf} for a detailing of the available algorithms. Several algorithms can be chained (processed in the order they are defined) by repeated this !algorithm! field with the same !primary_field!.
\begin{itemize}
\item !name!: Name of the algorithm, e.g. !to_upper!.
\item !primary_field!: The field number to apply this algorithm to. 
\end{itemize}
\end{itemize}
\item !publish!: Upon receipt of a Protobuf message, how to publish it back to one or more MOOS variable(s). Several !publish! entries should be specified to publish to several MOOS variables.
\begin{itemize}
\item !technique!: The serialization technique to use. See section \ref{sec:ptranslator_techniques}.
\item !moos_var!: The MOOS variable to write to for this !publish!. 
\item !format!: For !TECHNIQUE_FORMAT!, the format string to use. This is similar to printf, but instead of type specifiers, numerical specifiers are used, surrounded by !%! on both sides. For example, if the !format! value is !foo=%1%!, this !publish! will write a !moos_var! containing !foo=5! if field 1 in the Protobuf message was !5!. %
\item !repeated_delimiter!: When writing !repeated! Protobuf fields, this is the string that is used to delimit fields. 
\item !algorithm!: Several algorithms can be chained (processed in the order they are defined) by repeated this !algorithm! field with the same !primary_field!.
\begin{itemize}
\item !name!: Name of the algorithm, e.g. !to_upper!.
\item !primary_field!: The field number to apply this algorithm to. 
\item !output_virtual_field!: A ``virtual'' field number (one that doesn't exist in the actual Protobuf message) that is used to specify the output of this algorithm. This virtual field can then be used in the !format! string like a real field. 
\item !reference_field!: The field(s) required by the algorithm as references, if the algorithm requires them (e.g. !utm_x2lon!).
\end{itemize}
\end{itemize}
\item !use_short_enum!: If true, the front of the enumeration value is removed if it matches the field name plus a !_!. For example, if the enum field is !foo!, and the enumerations are !FOO_OPTION1!, !FOO_OPTION2!, then !OPTION1! and !OPTION2! are published. If false (the default), the enumeration values are published as defined. This is mostly here for backwards compatibility with Goby 1.
\end{itemize}
\end{itemize}


\section{Translator techniques}
\label{sec:ptranslator_techniques} 

There are three broad categories of translator techniques: 1) those that use the Google Protocol Buffers tools (!TECHNIQUE_PREFIXED_PROTOBUF_TEXT_FORMAT!, \\ !TECHNIQUE_PROTOBUF_TEXT_FORMAT!, !TECHNIQUE_PROTOBUF_NATIVE_ENCODED!), 2) one that uses the \textit{de facto} MOOS convention of !key=value! pairs delimited by commas \\(!TECHNIQUE_COMMA_SEPARATED_KEY_EQUALS_VALUE_PAIRS!), and 3) one that is based roughly on printf/scanf (!TECHNIQUE_FORMAT!).

More details on each translator type:
\begin{itemize}
\item !TECHNIQUE_PROTOBUF_TEXT_FORMAT!: exactly the same as if you used the Google TextFormat class: \url{https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.text_format}.
\item !TECHNIQUE_PREFIXED_PROTOBUF_TEXT_FORMAT! (recommendated for most uses). Same as !TECHNIQUE_PROTOBUF_TEXT_FORMAT! but prefixed with !@PB[TypeName] !, so that you can put multiple Protobuf Types in a single MOOS Variable (if you really need to). It's also quite human readable and allows for programs to read / write generic Protobuf messages. This technique is useful enough, there are two shortcut functions for use in your C++ MOOS code\\(!#include "goby/moos/moos_protobuf_helpers.h"!): !serialize_for_moos! and \\!parse_for_moos!.
\item !TECHNIQUE_PROTOBUF_NATIVE_ENCODED!: exactly the same as if you used the default binary Google encoding (binary), represented as a byte string. This tends to break the MOOS tools that assume strings are ASCII / UTF-8. 
\item !TECHNIQUE_COMMA_SEPARATED_KEY_EQUALS_VALUE_PAIRS!: all fields represented as !key1=value1,key2=value2,...! Messages with submessages are flattened and the keys assembled by concatenation separated with !_!. This is similar to the existing !NODE_REPORT! variable used in MOOS-IvP.
\item !TECHNIQUE_FORMAT!: sort of like !printf! / !scanf!, except instead of typed directives (e.g. !%d!), Goby uses numeric directives that correspond the protobuf message field id (e.g. !foobar=%2%!). Submessages can be referenced using ``:'' (e.g. !%5:1%!, where field 5 is a Message), repeated fields can be referenced using ``.'' (e.g. !%7.1%!, where field 7 is repeated). Note the ending !%! on each directive, which is different than !printf!. 
\end{itemize}

\section{pAcommsHandler}
\label{sec:pacommshandler} 

pAcommsHandler provides a:
\begin{enumerate}
\item MOOS Application wrapper for the Goby-Acomms communication library.
\item set of translation tools for converting the DCCL messages (written as an extension of Google Protocol Buffers) to MOOS types (strings and doubles) and vice-versa.
\item full backwards-compatibility support module for version 1 XML messages. 
\end{enumerate}

This section describes only the parts relevant for interface to MOOS (variables and translator entries that allow you to read and write to and from DCCL (Protobuf) messages). You should read Chapter \ref{chap:acomms} before starting this section and reference it as necessary.

\subsection{Parameters for the pAcommsHandler Configuration Block}\label{sec:pAcommsHandler:config}

\subsubsection{Example moos file}

pAcommsHandler has a large number of configuration options, many of which you will never use or leave as default. You can always get a complete listing of MOOS file parameters with their syntax by running
\begin{verbatim}
> pAcommsHandler --example_config
\end{verbatim}
\resetbvlinenumber

These configuration values are provided here (with $\ldots$ where the relevant configuration is provided elsewhere in this document):

\boxedverbatiminput{@RELATIVE_CMAKE_CURRENT_SOURCE_DIR@/includes/pAcommsHandler_reduced.moos}
\resetbvlinenumber


\subsubsection{Filling out the .moos file}\label{sec:pAcommsHandler_moos_file}

Many of the parameters are sufficiently explained in the above list of configuration parameters. What follows is a detailed explanation of the parameters that need further explanation.

\begin{itemize}
\item !common!: Parameters that can be set for any of the Goby MOOS applications. See section \ref{sec:goby_moos_app}.
\item !modem_id!: integer that specifies the !modem_id! of this current vehicle / community. For the WHOI Micro-Modem this is the Micro-Modem ``SRC'' configuration parameter (as set by !$CCCFG,SRC,#!). For the remainder of the document, !modem_id! refers to the value !$CCCFG,SRC,modem_id!. This configuration parameter will be set on startup. Setting this within the main block for pAcommsHandler sets it for all the modules (!driver_cfg!, !queue_cfg!, !mac_cfg!) 
\item !driver_type!: 
\begin{itemize}
\item !DRIVER_WHOI_MICROMODEM! is a driver for the WHOI Micro-Modem. 
\item !DRIVER_ABC_EXAMPLE_MODEM! is a simple test ``modem''. Do not use this for real work, but rather for learning how to write new drivers for Goby.
\item !DRIVER_UFIELD_SIM_DRIVER! is a driver for the MOOS-IvP uField toolbox.
\item !DRIVER_PB_STORE_SERVER! is a ZeroMQ (TCP, UNIX sockets) driver for the !goby_store_server! database.
\item !DRIVER_UDP! is a user datagram protocol (UDP) driver. This is probably the easiest driver to start with for learning pAcommsHandler.
\item !DRIVER_NONE! disables the modem driver.
\end{itemize}
\item !driver_cfg!: Configures the base driver and the specific driver selected. See section \ref{sec:driver}.
\item !mac_cfg!: Configures the acoustic Medium Access Control. See section \ref{sec:amac}.
\item !queue_cfg!: Configures the Priority Queuing layer. See section \ref{sec:queue}.
\item !dccl_cfg!: Configures the Dynamic Compact Control Language. See section \ref{sec:dccl}.
\item !route_cfg!: Configures a basic static routing module. This is experimental and subject to change.
\item !moos_var!: Rename any or all of the MOOS variables published by pAcommsHandler.
\item !load_shared_library!: Repeated string, each with a path to a shared library containing compiled DCCL (Google Protocol Buffers) messages.
\item !load_proto_file!: Repeated string, each with one path to a .proto file containing compiled DCCL (Google Protocol Buffers) messages. These will be compiled at runtime and loaded. It is preferable to use !load_shared_library! when possible, as syntactical and type mistakes in the DCCL messages will be caught at compile-time rather than delayed to runtime.
\item !translator_entry!: List of entries indicating when to make (\textit{trigger}) and how to \textit{create} outgoing DCCL messages, and how to \textit{publish} incoming DCCL messages. This can be thought of as providing a generic interface between MOOS strings and Google Protocol Buffers messages. See section \ref{sec:ptranslator} for a full explanation on how to configure this translation.
\item !multiplex_create_moos_var!: Used by !goby_liaison! to publish multiple commands (outgoing messages) on a single MOOS variable.
\item !modem_id_lookup_path!: path to a text file giving the mapping between !modem_id! and vehicle name and type for a given experiment. This file should look like:
\begin{boxedverbatim}
// modem id, vehicle name (should be community name), vehicle type
0, broadcast, broadcast
1, endeavor, ship
3, unicorn, auv
4, macrura, auv
\end{boxedverbatim}
\resetbvlinenumber
\item !transitional_cfg!: Provides the same functionality as !dccl_cfg! does in pAcommsHandler from version 1 of Goby. Behind the scenes, XML messages are read, translated to version 2 Protobuf DCCL messages, and written to the !generated_proto_dir!, and subsequently loaded using !load_proto_file!. The appropriate !translator_entry!s are also created from these messages. Do not use this configuration or the XML representation of DCCL messages for any new projects. See the version 1 documentation (\url{http://gobysoft.org/doc/1.1/}) for more details on the XML representation of DCCL messages.
\end{itemize}

%\subsection{MOOS variables subscribed to by pAcommsHandler}
%
%Except for the user-configured publishes (!translator_entry!), pAcommsHandler uses the \href{http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.text_format.html}{Google Protocol Buffers TextFormat} class for serializing to and parsing from MOOS strings (same as !TECHNIQUE_PREFIXED_PROTOBUF_TEXT_FORMAT!). This saves significant effort in manually parsing strings. You should use these same facilities for creating and reading messages. Two helper functions are provided in \\ \href{http://gobysoft.com/doc/moos__protobuf__helpers_8h.html}{goby/moos/libmoos\_util/moos\_protobuf\_helpers} will help you serialize and parse these messages. See \url{http://gobysoft.com/doc/2.0/acomms.html#protobuf} for a brief overview of Google Protocol Buffers as used in Goby.
%
%\begin{itemize}
%\item !DCCL!: Most variables subscribed to by pAcommsHandler are configured in the message XML files and are designated by the tags \xmltag{src\_var} (used to fetch data for a particular !message_var! within a DCCL message) and \xmltag{trigger\_var} (used to trigger the creatinon of a particular DCCL message and possibly provide some data for that message. See \ref{sec:dccl_overview} for details on the XML configuration. 
%\item !Queue!:
%\begin{itemize}
%\item Subscribes to the variables given in !queue_cfg.queue.in_pubsub_var! for CCL queue sending. The contents of this MOOS variable should be a serialized \href{http://gobysoft.com/doc/modem__message_8proto_source.html}{ModemDataTransmission}). 
%\item !ACOMMS_RANGE_COMMAND! (type: \href{http://gobysoft.com/doc/modem__message_8proto_source.html}{ModemRangingRequest}): You write this to initiate a ranging request outside the MAC schedule. Note in general it is preferable to use the MAC cycle to coordinate data and ranging.
%\end{itemize}
%\item !MAC!: !ACOMMS_MAC_CYCLE_UPDATE! (type: \href{http://gobysoft.com/doc/amac_8proto_source.html}{MACUpdate}) You write this to update the MAC cycle for !MAC_FIXED_DECENTRALIZED! and !MAC_POLLED! modes of operation.
%\end{itemize}
%
%For example, to publish a !ACOMMS_MAC_CYCLE_UPDATE!, you would use code like this:
%\begin{boxedverbatim}
%// provides serialize_for_moos
%#include <goby/moos/libmoos_util/moos_protobuf_helpers.h>
%// provides goby::acomms::protobuf::MACUpdate
%#include <goby/common/amac.pb.h>
%
%...
%
%MyMOOSApp::Iterate()
%{
%  if(do_update_mac)
%  { 
%    using namespace goby::acomms::protobuf;
%    MACUpdate mac_update;
%    mac_update.set_dest(1); // update for us if modem_id == 1
%    // add slot to end of existing cycle
%    mac_update.set_update_type(MACUpdate::ADD);
%    Slot* new_slot = mac_update.add_slot();
%    new_slot->set_src(1);  // send from us
%    new_slot->set_dest(3); // send to vehicle 3
%    new_slot->set_rate(0);
%    new_slot->set_slot_seconds(15);
%    new_slot->set_type(SLOT_DATA);
%    
%    std::string serialized;
%    serialize_for_moos (&serialized, mac_update);
%    m_Comms.Notify("ACOMMS_MAC_CYCLE_UPDATE", serialized);
%  }
%}
%\end{boxedverbatim}
%\resetbvlinenumber
%
%\subsection{MOOS variables published by pAcommsHandler}
%
%Except for DCCL \xmltag{publish\_var}s (which use a printf style syntax), pAcommsHandler uses the Google Protocol Buffers TextFormat class for serializing to MOOS strings. 
%
%\begin{itemize}
%\item !DCCL!: Most variables published by pAcommsHandler are configured in the message XML files and are designated by the tags \xmltag{publish\_var} within a \xmltag{publish} block. See \ref{sec:dccl_overview} for details on the XML configuration. 
%\item !Queue!:
%\begin{itemize}
%\item !ACOMMS_INCOMING_DATA! (type: \href{http://gobysoft.com/doc/modem__message_8proto_source.html}{ModemDataTransmission}) written for all received messages containing a data payload
%\item !ACOMMS_OUTGOING_DATA! (type: \href{http://gobysoft.com/doc/modem__message_8proto_source.html}{ModemDataTransmission}) written for all queued messages containing a data payload
%\item !ACOMMS_RANGE_RESPONSE! (type: \href{http://gobysoft.com/doc/modem__message_8proto_source.html}{ModemRangingReply}) written in response to ranging request (to another modem or LBL beacons)
%\item !ACOMMS_ACK! (type: \href{http://gobysoft.com/doc/modem__message_8proto_source.html}{ModemDataAck}) written when received data is acknowledged acoustically by a third party. Contains the original message.
%\item !ACOMMS_EXPIRE! (type: \href{http://gobysoft.com/doc/modem__message_8proto_source.html}{ModemDataExpire}) written when a message expires (time-to-live [ttl] exceeded) from the queue before being sent (ack = false) or acknowledged (ack = true)
%\item !ACOMMS_QSIZE! (type: \href{http://gobysoft.com/doc/queue_8proto_source.html}{QueueSize}) written when a queue changes size (pop or push) with the new size of the queue.
%\end{itemize}
%\item !MAC!: Does not publish anything.
%\item !ModemDriver!: 
%\begin{itemize}
%\item !ACOMMS_NMEA_IN! (type: string), ModemMsgBase::raw() for all incoming messages ("\$CA..." for WHOI Micro-Modem)
%\item !ACOMMS_NMEA_OUT! (type: string), ModemMsgBase::raw() for all outgoing messages ("\$CC..." for WHOI Micro-Modem)
%\end{itemize}
%\end{itemize}
%
%For example, to read an !ACOMMS_RANGE_RESPONSE!, you would use code like this:
%\begin{boxedverbatim}
%// provides parse_for_moos
%#include <goby/moos/libmoos_util/moos_protobuf_helpers.h>
%// provides goby::acomms::protobuf::ModemRangeReply
%#include <goby/common/modem_message.pb.h>
%
%...
%
%MyMOOSApp::OnNewMail()
%{
%  ...
%  if(moos_msg.GetKey() == "ACOMMS_RANGE_RESPONSE")
%  {
%    using namespace goby::acomms::protobuf;
%    ModemRangeReply range_response;
%    parse_for_moos (serialized, &range_response);
%    
%    // now do what you want to with the nice `range_response` object
%    std::cout << "one way travel time to " << range_response.base().dest() 
%              << " is " << range_response.one_way_travel_time(0) << std::endl;
%  }
%}
%\end{boxedverbatim}
%\resetbvlinenumber
%
%\subsection{Simple complete example MOOS files}
%
%\subsubsection{Example 1: Basic CCL (goby/share/cfg/MOOS/basic\_ccl)}\label{sec:moos_example_1}
%This example sends the bytes !0x020304! from node 1 (!mm1!) to node 2 (!mm2!). It shows use of all the parts of pAcommsHandler except the DCCL encoding / decoding unit. I use !iModemSim! here to simulate the WHOI Micro-Modem. This process is available in moos-ivp-local (\url{http://oceanai.mit.edu/moos-ivp/pmwiki/pmwiki.php?n=Support.Milocal}). You can also easily substitute real modems by removing iModemSim references and changing the !serial_port!.
%
%\paragraph{MOOS file for Node 1: goby/share/cfg/MOOS/basic\_ccl/mm1.moos}
%\boxedverbatiminput{"@RELATIVE_CMAKE_SOURCE_DIR@/share/cfg/MOOS/basic_ccl/mm1.moos"}
%\resetbvlinenumber
%
%\paragraph{MOOS file for Node 2: goby/share/cfg/MOOS/basic\_ccl/mm2.moos}
%\boxedverbatiminput{"@RELATIVE_CMAKE_SOURCE_DIR@/share/cfg/MOOS/basic_ccl/mm2.moos"}
%\resetbvlinenumber
%
%\subsubsection{Example 2: DCCL and CCL (goby/share/cfg/MOOS/ccl\_and\_dccl)}\label{sec:ccl_dccl_example}
%This example sends the DCCL ``Simple Status'' messsage from node 1 (!mm1!) to node 2 (!mm2!). !mm2! sends the REMUS CCL State message to !mm1!. It thus uses all the components of pAcommsHandler. As in the previous example, you can use real modems by removing iModemSim and changing the !serial_port! to the proper real serial port.
%
%\paragraph{MOOS file for Node 1: goby/share/cfg/MOOS/ccl\_and\_dccl/mm1.moos}
%\boxedverbatiminput{"@RELATIVE_CMAKE_SOURCE_DIR@/share/cfg/MOOS/ccl_and_dccl/mm1.moos"}
%\resetbvlinenumber
%
%\paragraph{MOOS file for Node 2: goby/share/cfg/MOOS/ccl\_and\_dccl/mm2.moos}
%\boxedverbatiminput{"@RELATIVE_CMAKE_SOURCE_DIR@/share/cfg/MOOS/ccl_and_dccl/mm2.moos"}
%\resetbvlinenumber
%
%\paragraph{XML definition of Simple Status: goby/xml/simple\_status.xml}
%\boxedverbatiminput{"@RELATIVE_CMAKE_SOURCE_DIR@/share/xml/simple_status.xml"}
%\resetbvlinenumber
%
%\paragraph{Modem Lookup Table: goby/share/cfg/MOOS/ccl\_and\_dccl/modemidlookup.txt}
%\boxedverbatiminput{"@RELATIVE_CMAKE_SOURCE_DIR@/share/cfg/MOOS/ccl_and_dccl/modemidlookup.txt"}
%\resetbvlinenumber

\section{MOOS Plugins for Goby Liaison}\label{sec:moos_liaison} 

Goby2 provides two applications (``tabs'') inside Liaison (see section \ref{sec:liaison}) that can launched by setting the environmental variable !GOBY_LIAISON_PLUGINS! to include the library !libliaison_plugins_goby_moos.so!. For example, in !bash!:

\begin{verbatim}
export GOBY_LIAISON_PLUGINS=/usr/lib/libliaison_plugins_goby_moos.so
goby_liaison
\end{verbatim}

Please note that multiple plugin libraries can be loaded by separating the library paths with colons. The MOOS Plugins are: 1) MOOSCommander, an application that allows operator entry of any Protobuf message, and 2) MOOSScope, a tool that allows examining some subset of the current MOOSDB variables. 

\subsection{Connecting the Goby Liaison to the MOOSDB using moos\_gateway\_g}\label{sec:moos_gateway_g}

Liaison does not use the standard CMOOSCommClient TCP transport that MOOS uses, but rather ZeroMQ \cite{zmq}. However, the Goby application !moos_gateway_g! was written to allow messages to pass between these two different ``worlds.'' The !moos_gateway_g! makes a ZeroMQ publish/subscribe connection on one side, and a CMOOSCommClient connection to a !MOOSDB! on the other. Messages are passed between the two worlds using a set of configured filters.

The configuration available is (!moos_gateway_g --example_config!):

\boxedverbatiminput{@RELATIVE_CMAKE_CURRENT_SOURCE_DIR@/includes/moos_gateway_g.pb.cfg}
\resetbvlinenumber

\begin{itemize}
\item !base!: Shared configuration for all !goby_common! applications. See section \ref{sec:base_cfg}. This includes the publish-subscribe configuration required to connect to the Goby ZeroMQ side of the gateway.
\item !moos_server_host!: IP address or domain name for the !MOOSDB!
\item !moos_server_port!: Port to connect to the !MOOSDB!
\item !moos_comm_tick!: Frequency to call into the !MOOSDB! to retrieve mail.
\item !moos_subscribe_filter!: A repeated string containing a substring to subscribe for in the MOOSDB. That is, !"NAV_"! will subscribe to !NAV_X!, !NAV_Y!, !NAV_DEPTH!, etc. The empty string (!""!) subscribes to everything.
\item !goby_subscribe_filter!: Same as the !moos_subscribe_filter! but for the Goby side.
\end{itemize}


\subsection{MOOS Commander GUI (Liaison)}

\begin{figure}
\centering
\includegraphics[width=7.5in, angle=90]{liaison_commander.png}
\caption{The MOOS Commander tab in Goby Liaison}
\label{fig:liaison_commander}
\end{figure}


The MOOS Commander tab is shown (with annotations) in Fig. \ref{fig:liaison_commander}. This is tool that allows a human operator to send DCCL messages (typically commands) to one or more robots. It supports sending any DCCL message (and any regular Protobuf message) known either at compile time  (!load_shared_library!) or runtime (!load_proto_file!).


When the MOOS plugins are loaded, the Commander tab can be configured with the following settings with the file passed to Liaison:

\boxedverbatiminput{@RELATIVE_CMAKE_CURRENT_SOURCE_DIR@/includes/moos_commander_liaison.pb.cfg}
\resetbvlinenumber


\begin{itemize}
\item !load_protobuf_name!: Repeated field, each with the full name of a Protobuf message as given by the !google::protobuf::Descriptor::full_name()!. This is the package name(s), followed by the message name, delimited by periods. For example, !example.MinimalStatus!. The messages will be loaded from !load_shared_library!, !load_proto_file!, and/or !load_proto_dir! configuration values given in the Liaison configuration, and made available for sending using the MOOS Commander GUI.
\item !value_width_pixels!: Change the display width of the !value! field (in pixels).
\item !modify_width_pixels!:  Change the display width of the !modify! field (in pixels).
\item !sqlite3_database!: Path to an SQLite3 database file to use (or create) to store all previously sent messages. Delete or modify this file to remove the history.
\item !database_pool_size!: The connection pool size for database connections. Generally this should be larger than the number of expected simultaneously connection clients to Liaison.
\item !database_view_height!: The height of the !Message log! section of the GUI (in pixels).
\item !database_width!: The widths (in pixels) of various components of the !Message log! section.
\item !modal_dimensions!:  The dimensions (in pixels) of the modal (popup) dialog when sending a message. 
\item !subscription!: A repeated field, each contains a MOOS variable name to subscribe for. Subscribed variables will be shown in the lower left corner of the Commander GUI.
\item !time_source_var!: The source of time e.g. !DB_TIME! from the MOOS database to be used for !codec="_time"! DCCL fields.
\end{itemize}


\subsection{MOOS Scope GUI (Liaison)}

\boxedverbatiminput{@RELATIVE_CMAKE_CURRENT_SOURCE_DIR@/includes/moos_scope_liaison.pb.cfg}
\resetbvlinenumber

\begin{itemize}
\item !subscription!: A repeated field, each with the string name of a MOOS variable. You can optionally use !*! at the end of the string for basic globbing. Use !regex_filter_expression! below for more advanced filtering. You can subscribe to !"*"! for all variables. Note that receiving mail for subscribed variables consumes network bandwidth, so it may be useful to subscribe to a small subset of variables before filtering when on a limited network connection.
\item !column_width!: Width (in pixels) for the individual scope columns.
\item !sort_by_column!: Which column to sort by on startup: Options are !COLUMN_KEY!, !COLUMN_TYPE!, !COLUMN_VALUE!, !COLUMN_TIME!, !COLUMN_COMMUNITY!, !COLUMN_SOURCE!, !COLUMN_SOURCE_AUX!, !COLUMN_MAX!.
\item !sort_ascending!: If true, sort ascending; if false, sort descending.
\item !scope_height!: Height (in pixels) of the scope display.
\item !regex_filter_column!: Which column to apply the !regex_filter_expression! to.
\item !regex_filter_expression!: A regular expression used to filter the scope results. Defaults to !".*"! which is an all-pass filter.
\item !history!: Enable one or more history panels showing the log of a given MOOS variable.
\begin{itemize}
\item !key!: The MOOS variable name to show history for.
\item !show_plot!: If true, shows a graph of the variable history. Only valid for MOOS double types.
\item !plot_width!: Width of the plot in pixels.
\item !plot_height!: Height of the plot in pixels.
\end{itemize}
\end{itemize}

\begin{figure}
\centering
\includegraphics[width=7.5in, angle=90]{liaison_scope.png}
\caption{The MOOS Scope tab in Goby Liaison}
\label{fig:liaison_scope}
\end{figure}

\subsection{Example working configuration}

Here are the configuration files for !moos_gateway_g! and !goby_liaison! with the MOOS plugins enabled from a working system as an example:

\boxedverbatiminput{@RELATIVE_CMAKE_CURRENT_SOURCE_DIR@/includes/moos_gateway_g_ex1.pb.cfg}
\resetbvlinenumber

\boxedverbatiminput{@RELATIVE_CMAKE_CURRENT_SOURCE_DIR@/includes/goby_liaison_ex1.pb.cfg}
\resetbvlinenumber


\section{Migrating from Version 1 to Version 2} \label{sec:gobyv1_migrate}

pAcommsHandler from Goby version 2 (Goby2) provides nearly full backwards compatibility directly using the XML messages from Goby version 1 (Goby1). 

In order to use XML messages from Goby1 in Goby2, simply rename the !dccl_cfg! section of the pAcommsHandler1 configuration block to !transitional_cfg!. In general this is all that needs to be done, as pAcommsHandler2 will automatically internally convert the XML files to .proto files and load them. Some special features of the XML files are not supported in version 2:

\begin{itemize}
\item Algorithms without a corresponding source variable.
\item Algorithms with reference fields (e.g. subtract:timestamp) for message creation. Reference fields are still allowed upon publish.
\item \xmltag{format} tags must be specified in the boost::format !%1%!, !%2%!, etc. format, not using !%d! printf specifiers. The typed specifiers would work in Goby v1 but are not supported at all in Goby v2.
\end{itemize}

While the XML files can be used directly as a temporary measure, it is recommended to transition all your XML files to .proto files for direct use with pAcommsHandler2. To ease your transition, there is a tool !dccl_xml_to_dccl_proto! that will automatically convert your XML files for you. The usage is 
\begin{verbatim}
dccl_xml_to_dccl_proto message_xml_file.xml [directory for generated .proto (default = pwd (.)]
\end{verbatim}

In Goby1, the XML files contained both structure information and MOOS translation information. In Goby2, these are separated to allow better support of non-MOOS systems. 

The tool will write the generated .proto files (the structure information) to the directory specified as the second command line parameter (defaults to the current/working directory). It will write to standard output the required additions to the pAcommsHandler2 configuration file for the queuing and translation information present in the XML file. Simply copy these parts to your MOOS file and you can continue to use your old messages natively.


\section{iCommander}\label{sec:icommander} 

\textit{Deprecated. Use goby\_liaison as a replacement. See section \ref{sec:moos_liaison}.}

\section{pREMUSCodec}

\textit{Deprecated, see section \ref{sec:ccl_dccl_example} for an example of using pAcommsHandler with CCL.}

\DeleteShortVerb{\!}
