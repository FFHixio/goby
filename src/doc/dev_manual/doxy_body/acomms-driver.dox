// copyright 2009-2011 t. schneider tes@mit.edu
// 
// goby software and documentation is distributed under the GNU General
// Public License v3.
//
// You should have received a copy of the GNU General Public License
// along with this software (see goby/COPYING).  If not, see <http://www.gnu.org/licenses/>.

/*! \page acomms_driver goby-acomms: modemdriver (Driver to interact with %modem firmware)

Table of contents for \c modemdriver:
<ul>
<li> \ref acomms_driverbase
<li> \ref acomms_modemtransmission
<li> \ref acomms_writedriver
<li> \ref acomms_mmdriver
</ul>


Return to \ref acomms.

\section acomms_driverbase Abstract class: ModemDriverBase

goby::acomms::ModemDriverBase defines the core functionality for an acoustic %modem. It provides

<ul>
<li><b>A serial or serial-like (over TCP) reader</b>. This is an instantiation of an appropriate derivative of the goby::util::LineBasedInterface class which reads the physical interface (serial or TCP) to the acoustic modem. The data (assumed to be ASCII lines offset by a delimiter such as NMEA0183 or the Hayes command set [AT]) are read into a buffer for use by the goby::acomms::ModemDriverBase derived class (e.g. goby::acomms::MMDriver). The type of interface is configured using a \link acomms_driver_base.proto goby::acomms::protobuf::DriverConfig\endlink. The modem is accessed by the derived class using goby::acomms::ModemDriverBase::modem_start, goby::acomms::ModemDriverBase::modem_read, goby::acomms::ModemDriverBase::modem_write, and goby::acomms::ModemDriverBase::modem_close.
<li>\b Signals to be called at the appropriate time by the derived class (goby::acomms::ModemDriverBase::signal_receive, goby::acomms::ModemDriverBase::signal_transmit_result, goby::acomms::ModemDriverBase::signal_data_request, goby::acomms::ModemDriverBase::signal_raw_incoming, goby::acomms::ModemDriverBase::signal_raw_outgoing).
At the application layer, either bind the %modem driver to a goby::acomms::QueueManager (goby::acomms::bind(goby::acomms::ModemDriverBase&, goby::acomms::QueueManager&) or connect custom function pointers or objects to the driver layer signals.  The goby::acomms::ModemDriverBase::signal_transmit_result, goby::acomms::ModemDriverBase::signal_raw_incoming and goby::acomms::ModemDriverBase::signal_raw_outgoing signals are for use by the application layer if desired to monitor or debug the functionality of the %modem.
<li><b>Virtual functions</b>  for starting the driver (goby::acomms::ModemDriverBase::startup), running the driver (goby::acomms::ModemDriverBase::do_work), and initiating the transmission of a message (goby::acomms::ModemDriverBase::handle_initiate_transmission). The handle_initiate_transmission slot is typically bound to goby::acomms::MACManager::signal_initiate_transmission.
</ul>

\subsection acomms_driverbase_interaction Interacting with the goby::acomms::ModemDriverBase

To use the goby::acomms::ModemDriverBase, you need to create one of its implementations such as \ref acomms_mmdriver.

\code
goby::acomms::ModemDriverBase* driver = new goby::acomms::MMDriver;
\endcode

You will also need to configure the driver. At the very least this involves a serial port, baud, and modem ID (integer MAC address for the modem).

\code
goby::acomms::protobuf::DriverConfig cfg;

cfg.set_serial_port("/dev/ttyS0");
cfg.set_modem_id(3);

\endcode

Most modems will have specific other configuration that is required. For example the WHOI Micro-Modem NVRAM is set using three character strings followed by a number. This modem-specific configuration is stored as Protobuf extensions to \link acomms_driver_base.proto goby::acomms::protobuf::DriverConfig\endlink, such as \link acomms_mm_driver.proto micromodem::protobuf::Config\endlink. If we were using the WHOI Micro-Modem and wanted to add an NVRAM configuration value we could write

\code
cfg.AddExtension(micromodem::protobuf::Config::nvram_cfg, "DQF,1");
\endcode

We need to connect any signals we are interested in. At a minimum this is goby::acomms::ModemDriverBase::signal_receive:

\code
goby::acomms::connect(&driver->signal_receive, &handle_data_receive);
\endcode

where handle_data_receive has the signature:
\code
void handle_data_receive(const goby::acomms::protobuf::ModemTransmission& data_msg);
\endcode

Next, we start up the driver with our configuration:

\code
driver->startup(cfg);
\endcode

We need to call goby::acomms::ModemDriverBase::do_work() on some reasonable frequency (greater than 5 Hz; 10 Hz is probably good). Whenever we need to transmit something, we can either directly call goby::acomms::ModemDriverBase::handle_initiate_transmission or connect goby::acomms::MACManager to do so for us on some TDMA cycle.

\section  acomms_modemtransmission Protobuf Message goby::acomms::protobuf::ModemTransmission

The \link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission\endlink message is used for all outgoing (sending) and incoming (receiving) messages. The message itself only contains the subset of modem functionality that every modem is expected to support (point-to-point transmission of datagrams).

All other functionality is provided by <a href="http://code.google.com/apis/protocolbuffers/docs/proto.html#extensions">extensions</a> to ModemTransmission such as those in acomms_mm_driver.proto for the WHOI Micro-Modem. These extensions provide access to additional features of the WHOI Micro-Modem (such as LBL ranging, two-way pings, and comprehensive receive statistics).

By making use of the Protobuf extensions in this way, Goby can both support unique features of a given modem while at that same time remaining general and agnostic to which modem is used when the features are shared (primarily data transfer).


\section acomms_writedriver Writing a new driver

All of goby-acomms is designed to be agnostic of which physical %modem is used. Different modems can be supported by subclassing goby::acomms::ModemDriverBase. You should check that a driver for your modem does not yet exist before attempting to create your own.

These are the requirements of the acoustic %modem:
<ul>
<li>it communicates using a line based text duplex connection using either serial or TCP (either client or server). NMEA0183 and AT (Hayes) protocols fulfill this requirement, for example.
<li>it is capable of sending and verifying the accuracy (using a cyclic redundancy check or similar error checking) of fixed size datagrams (note that modems capable of variable sized datagrams also fit into this category).
</ul>

Optionally, it can also support
<ul>
<li>Acoustic acknowledgment of proper message receipt.
<li>Ranging to another acoustic modem or LBL beacons using time of flight measurements
<li>User selectable bit rates
</ul>

The steps to writing a new driver include:

<ul>
<li>Fully understand the basic usage of the new acoustic modem manually using minicom or other terminal emulator. Have a copy of the modem software interface manual handy.
<li>Figure out what type of configuration the modem will need. For example, the WHOI Micro-Modem is configured using string values (e.g. "SNV,1"). Extend \link acomms_driver_base.proto goby::acomms::protobuf::DriverConfig\endlink to accomodate these configuration options. You will need to claim a group of extension field numbers that do not overlap with any of the drivers. The WHOI Micro-Modem driver goby::acomms::MMDriver uses extension field numbers 1000-1100 (see acomms_mm_driver.proto). You can read more about extensions in the official Google Protobuf documentation here: <http://code.google.com/apis/protocolbuffers/docs/proto.html#extensions>.

For example, if I was writing a new driver for the ABC Modem that needs to be configured using a few boolean flags, I might create a new message acomms_abc_driver.proto:

\include acomms_abc_driver.proto

make a note in acomms_driver_base.proto claiming extension numbers 1201 and 1202 (and others you may expect to need in the future). Extension field numbers can go up to 536,870,911 so don't worry about running out.
<li> Subclass goby::acomms::ModemDriverBase and overload the pure virtual methods (goby::acomms::ModemDriverBase::handle_initiate_ranging is optional). Your interface should look like this:

\dontinclude abc_driver.h
\skip namespace
\until private
\skipline driver_cfg_
\until }
\until }
\until }
             
<li> Fill in the methods. You are responsible for emitting the goby::acomms::ModemDriverBase signals at the appropriate times. Read on and all should be clear.
<ul>
<li>Minimally your constructor should store a local copy of the ostream logger:
\code
goby::acomms::ABCDriver::ABCDriver() : ModemDriverBase(log),
                         log_(log)
{
  // other initialization you can do before you have your goby::acomms::DriverConfig configuration object
}
\endcode
<li>At startup() you get your configuration from the application (pAcommsHandler or other)

\dontinclude abc_driver.cpp
\skipline startup
\until startup
<li>At shutdown() you should make yourself ready to startup() again if necessary and stop the modem:
\dontinclude abc_driver.cpp
\skipline shutdown
\until shutdown
<li>handle_initiate_transmission() is called when you are expected to initiate a transmission. It <i>may</i> contain data (in the ModemTransmission::frame field). If not, you are required to request data using the goby::acomms::ModemDriverBase::signal_data_request signal. Once you have data, you are responsible for sending it. I think a bit of code will make this clearer:
\dontinclude abc_driver.cpp
\skipline handle_initiate_transmission
\until handle_initiate_transmission
<li> Finally, you can use do_work() to do continuous work. You can count on it being called at 5 Hz or more (in pAcommsHandler, it is called on the MOOS AppTick). Here's where you want to read the modem incoming stream.
\dontinclude abc_driver.cpp
\skipline do_work
\until do_work
<li> Add your driver header to goby/src/acomms/modem_driver.h
<li> Modify \ref acomms/modemdriver/driver_simple/driver_simple.cpp "driver_simple.cpp" to work with your new driver.
<li> Add your driver to the pAcommsHandler_config.proto DriverType enumeration.
<li> Add your driver to the pAcommsHandler.cpp driver object creation.
</ul>
</ul>

The full ABC Modem example driver exists in acomms/modemdriver/abc_driver.h and acomms/modemdriver/abc_driver.cpp. A simulator for the ABC Modem exists that uses TCP to mimic a very basic set of modem commands (send data and acknowledgment). To use the ABC Modem using the driver_simple example, run this set of commands (`socat` is available in most package managers or at <http://www.dest-unreach.org/socat/>):

\verbatim
1. run abc_modem_simulator running on same port (as TCP server)
> abc_modem_simulator 54321
2. create fake tty terminals connected to TCP as client to port 54321
> socat -d -d -v pty,raw,echo=0,link=/tmp/ttyFAKE1 TCP:localhost:54321
> socat -d -d -v pty,raw,echo=0,link=/tmp/ttyFAKE2 TCP:localhost:54321
3. start up driver_simple
> driver_simple /tmp/ttyFAKE1 1 ABCDriver
// wait a few seconds to avoid collisions
> driver_simple /tmp/ttyFAKE2 2 ABCDriver
\endverbatim

Notes:
<ul>
<li>See goby::acomms::MMDriver for an example real implementation.
<li>When a message is sent to goby::acomms::BROADCAST_ID (0), it should be broadcast if the modem supports such functionality. Otherwise, the driver should throw an goby::acomms::DriverException indicating that it does not support broadcast allowing the user to reconfigure their MAC / addressing scheme.
</ul>


\section acomms_mmdriver WHOI Micro-Modem Driver: MMDriver

\subsection acomms_mmdriver_overview Supported Functionality 

The goby::acomms::MMDriver extends the goby::acomms::ModemDriverBase for the WHOI Micro-Modem acoustic %modem. It is tested to work with revision 0.94.0.00 of the Micro-Modem firmware, but is known to work with older firmware (at least 0.92.0.85). It is likely to work properly with newer firmware, and any problems while using newer Micro-Modem firmware should be filed as a <a href="https://bugs.launchpad.net/goby">bug in Goby</a>. The following features of the WHOI Micro-Modem are implemented, which comprise the majority of the Micro-Modem functionality:


<ul>
<li>FSK (rate 0) data transmission
<li>PSK (rates 1,2,3,4,5) data transmission
<li>Narrowband transponder LBL ping
<li>REMUS transponder LBL ping
<li>User mini-packet 13 bit data transmission
<li>Two way ping
</ul>

See the \ref acomms_mmdriver_uml "UML diagrams" for a graphical diagram of using Goby for each of these features.

\subsection acomms_mmdriver_mapping Micro-Modem NMEA to Goby ModemTransmission mapping

Mapping between acomms_modem_message.proto and acomms_mm_driver.proto messages and NMEA fields (see http://acomms.whoi.edu/documents/uModem%20Software%20Interface%20Guide.pdf for NMEA fields of the WHOI Micro-Modem):

Modem to Control Computer ($CA / $SN):
<table border=1>
<tr>
<td>NMEA talker</td>
<td>Mapping</td>
</tr>
<tr>
<td>$CAACK</td>
<td>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.src()\endlink = SRC<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.dest()\endlink = DEST<br>
(first CAACK for a given packet) \link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.acked_frame(0)\endlink = Frame#-1 (Goby starts counting at frame 0, WHOI starts with frame 1)<br>
(second CAACK for a given packet) \link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.acked_frame(1)\endlink = Frame#-1 <br>
(third CAACK for a given packet) \link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.acked_frame(2)\endlink = Frame#-1 <br>
...
</td>
</tr>
<tr>
<td>$CADRQ</td>
<td>
Data request is anticipated from the $CCCYC or $CACYC and buffered. Thus it is not translated into any of the acomms_modem_message.proto messages.
</td>
</tr>
<tr>
<td>$CARXD</td>
<td>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.type() \endlink = goby::acomms::protobuf::ModemTransmission::DATA <br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.src()\endlink = SRC<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.dest()\endlink = DEST<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.ack_requested()\endlink = ACK<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemTransmission.frame(F#-1)\endlink = goby::util::hex_decode(HH...HH) <br>
</td>
</tr>
<tr>
<td>$CACYC</td>
<td>
If we did not send $CCCYC, buffer data for $CADRQ by augmenting the provided ModemTransmission and calling signal_data_request:<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataRequest.base().src()\endlink = ADR1<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataRequest.base().dest()\endlink = ADR2<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataRequest.max_bytes()\endlink = 32 for Packet Type == 0, 64 for Packet Type == 2, 256 for Packet Type == 3 or 5<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataRequest.frame()\endlink = n <br>
</td>
</tr> 
<tr>
<td>$CAREV</td>
<td>Not translated into any of the acomms_modem_message.proto messages.</td>
</tr>
<tr>
<td>$CAERR</td>
<td>Not translated into any of the acomms_modem_message.proto messages.</td>
</tr>
<tr>
<td>$CAMPR</td>
<td>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.base().dest()\endlink = SRC (SRC and DEST flipped to be SRC and DEST of $CCMPC)<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.base().src()\endlink = DEST<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(0)\endlink = Travel Time<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.type()\endlink = goby::acomms::protobuf::MODEM_TWO_WAY_PING<br>
</td>
</tr>
<tr>
<td>$SNTTA</td>
<td>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.base().src()\endlink = modem_id<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(0)\endlink = TA<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(1)\endlink = TB<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(2)\endlink = TC<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(3)\endlink = TD<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.type()\endlink = goby::acomms::protobuf::REMUS_LBL_RANGING<br>
</td>
</tr>
<tr>
<td><a href="http://acomms.whoi.edu/documents/Synchronous%20Navigation%20With%20MicroModem%20RevD.pdf">$CATOA</a></td>
<td>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.base().src()\endlink = SRC (of related $CARXD, $CAACK)<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.base().dest()\endlink = DEST (of related $CARXD, $CAACK)<br>
Travel times are ambiguous: have to figure it out from knowledge we don't have here
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(0)\endlink = 0.SSSS<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(1)\endlink = 1.SSSS<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(2)\endlink = 2.SSSS<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.one_way_travel_time(n)\endlink = n.SSSS (n = floor(10000 m / 1500 m/s) since 10km is a sensible upper bound on the WHOI Micro-Modem performance) <br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingReply.type()\endlink = goby::acomms::protobuf::MODEM_ONE_WAY_SYNCHRONOUS<br>
</td>
</tr>
</table>

Control Computer to Modem ($CC):
<table border=1>
<tr>
<td>$CCTXD</td>
<td>
SRC = \link acomms_modem_message.proto goby::acomms::protobuf::ModemDataTransmission.base().src()\endlink<br>
DEST = \link acomms_modem_message.proto goby::acomms::protobuf::ModemDataTransmission.base().dest()\endlink<br>
A = \link acomms_modem_message.proto goby::acomms::protobuf::ModemDataTransmission.ack_requested()\endlink<br>
HH...HH = goby::acomms::hex_encode(\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataTransmission.data()\endlink)<br>
</td>
</tr>
<tr>
<td>$CCCYC</td>
<td>
CMD = 0 (deprecated field)<br>
ADR1 = \link acomms_modem_message.proto goby::acomms::protobuf::ModemDataInit.base().src()\endlink<br>
ADR2 = \link acomms_modem_message.proto goby::acomms::protobuf::ModemDataInit.base().dest()\endlink<br>
Packet Type = \link acomms_modem_message.proto goby::acomms::protobuf::ModemDataInit.base().rate()\endlink<br>
ACK = 0 (deprecated field)<br> 
Nframes = \link acomms_modem_message.proto goby::acomms::protobuf::ModemDataInit.num_frames()\endlink<br><br>
If ADR1 == modem_id, buffer data for later $CADRQ by sending this message n = 0 to Nframes times:<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataRequest.base().src()\endlink = ADR1<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataRequest.base().dest()\endlink = ADR2<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataRequest.max_bytes()\endlink = 32 for Packet Type == 0, 64 for Packet Type == 2, 256 for Packet Type == 3 or 5<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemDataRequest.frame()\endlink = n <br>
</td>
</tr> 
<tr>
<td>$CCCLK</td>
<td>Not translated from any of the acomms_modem_message.proto messages. (taken from the system time using the boost::date_time library)</td>
</tr>
<tr>
<td>$CCCFG</td>
<td>Not translated from any of the acomms_modem_message.proto messages. (taken from values passed to the extension \link acomms_mm_driver.proto MicroModemConfig::nvram_cfg\endlink of \link acomms_driver_base.proto goby::acomms::protobuf::DriverConfig\endlink)</td>
</tr>
<tr>
<td>$CCCFQ</td>
<td>Not translated from any of the acomms_modem_message.proto messages. $CCCFQ,ALL sent at startup.</td>
</tr>
<tr>
<td>$CCMPC</td>
<td>
protobuf::MODEM_TWO_WAY_PING == \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.type()\endlink<br>
SRC = \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.base().src()\endlink<br>
DEST = \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.base().dest()\endlink<br>
</td>
</tr>
<tr>
<td>$CCPDT</td>
<td>
protobuf::REMUS_LBL_RANGING == \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.type()\endlink<br>
GRP = 1<br>
CHANNEL = modem_id % 4 + 1 (use four consecutive modem_ids if you need multiple vehicles pinging)<br>
SF = 0<br>
STO = 0<br>
Timeout = \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.max_range()\endlink m *2/ 1500 m/s * 1000 ms/s<br>
\link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.enable_beacons()\endlink is a set of four bit flags where the least significant bit is AF enable, most significant bit is DF enable. Thus b1111 == 0x0F enables all beacons <br>
AF = \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.enable_beacons()\endlink >> 0 & 1<br>
BF = \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.enable_beacons()\endlink >> 1 & 1<br>
CF = \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.enable_beacons()\endlink >> 2 & 1<br>
DF = \link acomms_modem_message.proto goby::acomms::protobuf::ModemRangingRequest.enable_beacons()\endlink >> 3 & 1<br>
</td>
</tr>
</table>


\subsection acomms_mmdriver_uml Sequence diagrams for various Micro-Modem features using Goby

FSK (rate 0) data transmission
\image html goby-acomms-mmdriver-rate0.png
\image latex goby-acomms-mmdriver-rate0.eps "FSK (rate 0) data transmission"

PSK (rate 2 shown, others are similar) data transmission
\image html goby-acomms-mmdriver-rate2.png
\image latex goby-acomms-mmdriver-rate2.eps "PSK (rate 2 shown, others are similar) data transmission"

Narrowband transponder LBL ping
\image html goby-acomms-mmdriver-pnt.png
\image latex goby-acomms-mmdriver-pnt.eps "Narrowband transponder LBL ping"

REMUS transponder LBL ping
\image html goby-acomms-mmdriver-pdt.png
\image latex goby-acomms-mmdriver-pdt.eps "REMUS transponder LBL ping"

User mini-packet 13 bit data transmission
\image html goby-acomms-mmdriver-muc.png
\image latex goby-acomms-mmdriver-muc.eps "User mini-packet 13 bit data transmission"

Two way ping
\image html goby-acomms-mmdriver-mpc.png
\image latex goby-acomms-mmdriver-mpc.eps "Two way ping"



*/
