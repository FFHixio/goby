// copyright 2009-2011 t. schneider tes@mit.edu
// 
// this file is part of the Dynamic Compact Control Language (DCCL),
// the goby-acomms codec. goby-acomms is a collection of libraries 
// for acoustic underwater networking
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This software is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this software.  If not, see <http://www.gnu.org/licenses/>.

#ifndef DCCL20091211H
#define DCCL20091211H

#include <string>
#include <set>
#include <map>
#include <ostream>
#include <stdexcept>
#include <vector>

#include <google/protobuf/descriptor.h>

#include <boost/shared_ptr.hpp>

#include "goby/util/time.h"
#include "goby/util/logger.h"
#include "goby/core/core_constants.h"
#include "goby/protobuf/dccl.pb.h"
#include "goby/protobuf/modem_message.pb.h"
#include "goby/acomms/acomms_helpers.h"
#include "goby/util/binary.h"

#include "protobuf_cpp_type_helpers.h"
#include "dccl_exception.h"
#include "dccl_field_codec.h"
#include "dccl_field_codec_fixed.h"
#include "dccl_type_helper.h"
#include "dccl_field_codec_manager.h"

// The global namespace for the Goby project.
namespace goby
{
    namespace util
    { class FlexOstream; }
 
 
    /// Objects pertaining to acoustic communications (acomms)
    namespace acomms
    {
        class DCCLFieldCodec;
  
        /// \class DCCLCodec dccl.h goby/acomms/dccl.h
        /// \brief provides an API to the Dynamic CCL Codec.
        /// \ingroup acomms_api
        /// \sa dccl.proto and modem_message.proto for definition of Google Protocol Buffers messages (namespace goby::acomms::protobuf).
        ///
        /// Simple usage example:
        /// 1. Define a Google Protobuf message with DCCL extensions:
        /// \verbinclude simple.proto
        /// 2. Write a bit of code like this:
        /// \code
        /// goby::acomms::DCCLCodec* dccl = goby::acomms::DCCLCodec::get();
        /// dccl->validate<Simple>();
        /// Simple message_out;
        /// message_out.set_telegram("Hello!");
        /// std::string bytes = dccl->encode(message);
        /// \\ send bytes across some network
        /// Simple message_in = dccl->decode<Simple>(bytes);
        /// \endcode
        /// \example acomms/chat/chat.cpp
        /// \example acomms/libdccl/dccl_simple/dccl_simple.cpp
        /// simple.proto
        /// \verbinclude simple.proto
        /// dccl_simple.cpp
        class DCCLCodec
        {
          public:
            /// \brief DCCLCodec is a singleton class; use this to get a pointer to the class.
            static DCCLCodec* get() 
            {
                // set these now so that the user has a chance of setting the logger
                if(!inst_)
                    inst_.reset(new DCCLCodec);

                return inst_.get();    
            }
            
            /// \name Initialization Methods.
            ///
            /// These methods are intended to be called before doing any work with the class. However,
            /// they may be called at any time as desired.
            //@{

            /// \brief Set (and overwrite completely if present) the current configuration. (protobuf::DCCLConfig defined in dccl.proto)
            void set_cfg(const protobuf::DCCLConfig& cfg);
            
            /// \brief Set (and merge "repeated" fields) the current configuration. (protobuf::DCCLConfig defined in dccl.proto). Non-repeated fields will be overwritten if set.
            void merge_cfg(const protobuf::DCCLConfig& cfg);

            /// \brief All messages must be validated (size checks, option extensions checks, etc.) before they can be encoded/decoded. Use this form when the messages used are static (known at compile time).
            ///
            /// \tparam ProtobufMessage Any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message)
            /// \return true if message validates successfully, false if not. Warnings and errors are written to goby::glog.
            template<typename ProtobufMessage>
                bool validate()
            { return validate(ProtobufMessage::descriptor()); }

            //@}            


            
            /// \name Informational Methods.
            ///
            /// Provides various forms of information about the DCCLCodec
            //@{

            /// \brief Writes a human readable summary (including field sizes) of the provided DCCL type to the stream provided.
            ///
            /// \tparam ProtobufMessage Any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message)
            /// \param os Pointer to a stream to write this information
            template<typename ProtobufMessage>
                void info(std::ostream* os)
            { info(ProtobufMessage::descriptor(), os); }

            
            /// \brief Gives the DCCL id (defined by the custom message option extension "dccl.id" in the .proto file). This ID is used on the wire to unique identify incoming message types.
            ///
            /// \tparam ProtobufMessage Any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message)
            template <typename ProtobufMessage>
                unsigned id()
            { return id(ProtobufMessage::descriptor()); }            
            
            /// \brief Provides the encoded size (in bytes) of msg. This is useful if you need to know the size of a message before encoding it (encoding it is generally much more expensive than calling this method)
            ///
            /// \param msg Google Protobuf message with DCCL extensions for which the encoded size is requested
            /// \return Encoded (using DCCL) size in bytes
            unsigned size(const google::protobuf::Message& msg);

            //@}
       
            /// \name Codec functions.
            ///
            /// This is where the real work happens.
            //@{

            /// \brief Encodes a DCCL message
            ///
            /// \param msg Message to encode (must already have been validated)
            /// \return string contained encoded message (the returned string is used simply as a container for bytes, pass this to goby::util::hex_encode for a hexadecimal string).
            std::string encode(const google::protobuf::Message& msg);
            
            /// \brief Decode a DCCL message when the type is known at compile time.
            ///
            /// \tparam ProtobufMessage Any Google Protobuf Message generated by protoc (i.e. subclass of google::protobuf::Message)
            /// \param bytes encoded message to decode (must already have been validated)
            /// \return Decoded message.
            template<typename ProtobufMessage>
                ProtobufMessage decode(const std::string& bytes)
            {
                ProtobufMessage msg;
                msg.CopyFrom(*decode(bytes));
                return msg;
            }

            /// \brief Get the DCCL ID of an unknown encoded DCCL message
            /// 
            /// \param bytes encoded message to get the DCCL ID of
            /// \return DCCL ID
            unsigned id_from_encoded(const std::string& bytes);
            

            //@}

            /// \name Alternative Dynamic Protobuf methods (including list of Message methods) (Advanced)
            ///
            /// These methods are intended to be used when the Google Protobuf message types are not known at compile-time, and work with the <a href="http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.descriptor.html">Descriptor</a>/<a href="http://code.google.com/apis/protocolbuffers/docs/reference/cpp/google.protobuf.message.html#Reflection">Reflection</a> meta-data introspection API provided by Google.
            //@{

            
            /// \brief An alterative form for validating messages for message types <i>not</i> known at compile-time ("dynamic").
            ///
            /// \param desc The Google Protobuf "Descriptor" (meta-data) of the message to validate.
            /// \return true if message validates successfully, false if not
            bool validate(const google::protobuf::Descriptor* desc);

            /// \brief Shortcut for validating multiple messages at once
            bool validate_repeated(const std::list<const google::protobuf::Descriptor*>& desc);
            
            /// \brief An alterative form for getting information for messages for message types <i>not</i> known at compile-time ("dynamic").
            void info(const google::protobuf::Descriptor* desc, std::ostream* os);

            /// \brief Shortcut for getting information on multiple messages at once
            void info_repeated(const std::list<const google::protobuf::Descriptor*>& desc, std::ostream* os);

            /// \brief Provides the DCCL ID given a DCCL type.
            unsigned id(const google::protobuf::Descriptor* desc) {
                return desc->options().GetExtension(dccl::id);
            }
            
            /// \brief Returns the encoded size of multiple messages at once (sum of all sizes). You must use this method (instead of N calls to size, where N is msgs.size()) to get the size of messages encoded using encode_repeated as repeated encoding may be more efficient (in terms of the encoded message size) than N calls of encode
            ///
            /// \tparam GoogleProtobufMessagePointer anything that acts like a pointer (has operator*) to a google::protobuf::Message (smart pointers like boost::shared_ptr included)
            /// \param msgs list of DCCL messages to get the sizes of
            /// \return total size of the encoded messages in bytes
            template<typename GoogleProtobufMessagePointer>
                unsigned size_repeated(const std::list<GoogleProtobufMessagePointer>& msgs)
            {
                unsigned out = 0;
                BOOST_FOREACH(const GoogleProtobufMessagePointer& msg, msgs)
                    out += size(*msg);
                return out;
            }

            /// \brief An alterative form for decoding messages for message types <i>not</i> known at compile-time ("dynamic").
            ///
            /// \param bytes the byte string returned by encode
            boost::shared_ptr<google::protobuf::Message> decode(const std::string& bytes);
            
            /// \brief Encode multiple messages at once. In general this is more efficient (i.e. produces smaller messages) than calling encode repeatedly.
            ///
            /// \tparam GoogleProtobufMessagePointer anything that acts like a pointer (has operator*) to a google::protobuf::Message (smart pointers like boost::shared_ptr included)
            /// \param msgs list of DCCL messages to encode
            /// \return string containing bytes that represent the encoded message
            template<typename GoogleProtobufMessagePointer>
                std::string encode_repeated(const std::list<GoogleProtobufMessagePointer>& msgs)
            {
                std::string out;
                BOOST_FOREACH(const GoogleProtobufMessagePointer& msg, msgs)
                {
                    out += encode(*msg);
                    goby::glog.is(debug2) && goby::glog << "out: " << goby::util::hex_encode(out) << std::endl;
                }
    
                return out;
            }
            
            /// \brief Decode multiple messages at once. Messages encoded using encode_repeated must be decoded using decode_repeated.
            ///
            /// \param bytes string of bytes produced by encoded_repeated
            /// \return list of smart pointers to the decoded messages
            std::list<boost::shared_ptr<google::protobuf::Message> > decode_repeated(const std::string& bytes);
            
            //@}


            /// \name Hook API (Advanced)
            ///
            /// Register hooks (callbacks) to be called when a certain Google Protobuf option extension is encountered while exploring the Google Protobuf descriptor (message meta-data). This is used by libqueue to identify its option extensions (queue.is_src, queue.is_dest, etc.). You may be able to find another use for it as well!

            //@{
            /// \brief run hooks previously registered to DCCLFieldCodec::register_wire_value_hook
            void run_hooks(const google::protobuf::Message& msg);
            //@}           
            

          private:

            // so we can use shared_ptr to hold the singleton
            template<typename T>
                friend void boost::checked_delete(T*);

            DCCLCodec();
            ~DCCLCodec() { }
            DCCLCodec(const DCCLCodec&);
            DCCLCodec& operator= (const DCCLCodec&);
            
            void encrypt(std::string* s, const std::string& nonce);
            void decrypt(std::string* s, const std::string& nonce);
            void process_cfg();

            // maximum id we can fit in short or long header (MSB reserved to indicate
            // short or long header)
            enum { ONE_BYTE_MAX_ID = (1 << 7) - 1,
                   TWO_BYTE_MAX_ID = (1 << 15) - 1};

            enum { SHORT_FORM_ID_BYTES = 1,
                   LONG_FORM_ID_BYTES = 2 };
            
            
            Bitset encode_id(int id);
            int decode_id(Bitset bits);
            int size_id(int id);
                
            void set_default_codecs();            
            
          private:
            static boost::shared_ptr<DCCLCodec> inst_;
            
            const std::string DEFAULT_CODEC_NAME;

            protobuf::DCCLConfig cfg_;
            // SHA256 hash of the crypto passphrase
            std::string crypto_key_;
            
            // maps `dccl.id`s onto Message Descriptors
            std::map<int32, const google::protobuf::Descriptor*> id2desc_;

        };
                                      
        
    }
}

#endif
