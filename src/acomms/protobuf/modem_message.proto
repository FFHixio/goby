import "goby/acomms/protobuf/queue.proto";
// TODO(tes) consider using extensions to handle different modem characteristics

package goby.acomms.protobuf;

// shared for all messages
message ModemMsgBase
{
  optional int32 src = 1 [default = 0]; //  0 (BROADCAST), 1-31, 
  optional int32 dest = 2 [default = 0]; //  0 (BROADCAST), 1-31, -1 (QUERY_DESTINATION_ID)
  required string time = 3; // UTC time output from operator<< of boost::posix_time::ptime: e.g. "2002-Jan-01 14:23:11"
  enum TimeSource { MODEM_TIME = 1; GOBY_TIME = 2; } 
  optional TimeSource time_source = 5 [default = GOBY_TIME]; // source of the timestamp given  
  optional uint32 rate = 6 [default = 0]; // 0 (lowest) - 5 (highest)
  optional string raw = 7; // "$CARXD,..."
  optional string description = 8; // "Incoming hexadecimal data"
}

// data 
message ModemDataTransmission
{
  required ModemMsgBase base = 1;
  optional bool ack_requested = 2 [default = true]; // acoustic acknowledgment requested
  //  optional uint32 max_bytes = 3;
  optional bytes data = 4; // data (encoded as a byte string - eight bits to the character)
  optional uint32 frame = 5 [default = 0];  // frame number if the modem supports multiple frames per packet
  optional QueueKey queue_key = 6;

  extensions 1000 to max;
}

message ModemDataAck
{
  required ModemMsgBase base = 1;
  optional uint32 frame = 2 [default = 0];
  optional ModemDataTransmission orig_msg = 3; // will be provided by libqueue
  // TODO(tes) put DCCL header in here if DCCL
}

message ModemDataExpire
{
  optional ModemDataTransmission orig_msg = 1; // the message that just expired
}

message ModemDataRequest
{
  required ModemMsgBase base = 1;
  optional uint32 max_bytes = 2; // omitted means no maximum
  optional uint32 frame = 3 [default = 0]; 
 }

message ModemDataInit
{
  required ModemMsgBase base = 1;
  optional uint32 num_frames = 2 [default = 1];
}

// ranging
enum RangingType
{

  // modem 1 interrogates modem 2; modem 2 replies and modem 1 computes one way travel time
  MODEM_TWO_WAY_PING = 1; 

  // modems 1 and 2 have synchronous clocks. modem 2 sends to modem 1 at agreed upon time
  // and modem 1 computes one way travel time
  MODEM_ONE_WAY_SYNCHRONOUS = 2;

  // modem 1 pings a REMUS network of long baseline (LBL) beacons
  REMUS_LBL_RANGING = 3;
}

message ModemRangingReply
{
  required ModemMsgBase base = 1;
  // seconds
  repeated double one_way_travel_time = 2;  
  optional RangingType type = 3;
}

message ModemRangingRequest
{
  required ModemMsgBase base = 1;
  optional RangingType type = 2;

  // meters, not used if type == MODEM_RANGING
  optional uint32 max_range = 3 [default = 1000]; 
  
  // LSB->MSB is LBL beacons 1,2,3,... true is enabled, false is disabled
  // enable four beacons is b1111 == d15 
  optional uint32 enable_beacons = 4 [default = 15];
}
