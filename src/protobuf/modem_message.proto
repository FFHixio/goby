import "goby/protobuf/queue.proto";
// TODO(tes) consider using extensions to handle different modem characteristics

package goby.acomms.protobuf;

// shared for all messages
message ModemMsgBase
{
  optional int32 src = 1 [default = 0]; //  0 (BROADCAST), 1-31, 
  optional int32 dest = 2 [default = 0]; //  0 (BROADCAST), 1-31, -1 (QUERY_DESTINATION_ID)
  optional string time = 3; // UTC time output from operator<< of boost::posix_time::ptime: e.g. "2002-Jan-01 14:23:11"
  enum TimeSource { MODEM_TIME = 1; GOBY_TIME = 2; } 
  optional TimeSource time_source = 5 [default = GOBY_TIME]; // source of the timestamp given  
  optional uint32 rate = 6 [default = 0]; // 0 (lowest) - 5 (highest)
  optional string raw = 7; // "$CARXD,..."
  optional string description = 8; // "Incoming hexadecimal data"
}

// data 
message ModemDataTransmission
{
  optional ModemMsgBase base = 1;
  optional bool ack_requested = 2 [default = true]; // acoustic acknowledgment requested
  //  optional uint32 max_bytes = 3;
  optional bytes data = 4; // data (encoded as a byte string - eight bits to the character)
  optional uint32 frame = 5 [default = 0];  // frame number if the modem supports multiple frames per packet
  optional QueueKey queue_key = 6;
  // TODO(tes) put DCCL header in here if DCCL

  extensions 1000 to max;
}

message ModemDataAck
{
  optional ModemMsgBase base = 1;
  optional uint32 frame = 2 [default = 0]; // provided by libmodemdriver
  optional ModemDataTransmission orig_msg = 3; // will be provided by libqueue
}

message ModemDataExpire
{
  optional ModemDataTransmission orig_msg = 1; // the message that just expired
}

message ModemDataRequest
{
  optional ModemMsgBase base = 1;
  optional uint32 max_bytes = 2; // omitted means no maximum
  optional uint32 frame = 3 [default = 0]; 
 }

message ModemDataInit
{
  optional ModemMsgBase base = 1;
  optional uint32 num_frames = 2 [default = 1];
}

// mini-packet
// supports up to 7 types, for now only have 3
enum MiniType
{
    MINI_USER  = 1;
    MINI_OWTT  = 2;
    MINI_ABORT = 3;
}

enum ClockMode
{
    NO_SYNC_TO_PPS_AND_CCCLK_BAD = 0;
    NO_SYNC_TO_PPS_AND_CCCLK_GOOD = 1;
    SYNC_TO_PPS_AND_CCCLK_BAD = 2;
    SYNC_TO_PPS_AND_CCCLK_GOOD = 3;
    UNKNOWN = 4;
}

message ModemMiniTransmission
{
    optional ModemMsgBase base = 1;
    optional MiniType type = 2 [default = MINI_USER]; //default to normal message
    optional ClockMode clk_mode = 3 [default = UNKNOWN];
    optional int32 time_of_depart = 4 [default = -1];
    optional uint32 data = 5; // mini packets only allow 13bits
}

// ranging
enum RangingType
{

  // modem 1 interrogates modem 2; modem 2 replies and modem 1 computes one way travel time
  MODEM_TWO_WAY_PING = 1; 

  // modems 1 and 2 have synchronous clocks. modem 2 sends to modem 1 at agreed upon time
  // and modem 1 computes one way travel time
  MODEM_ONE_WAY_SYNCHRONOUS = 2;

  // modem 1 pings a REMUS network of long baseline (LBL) beacons
  REMUS_LBL_RANGING = 3;
}

message ModemRangingReply
{
  optional ModemMsgBase base = 1;
  // seconds
  optional double received_time = 2;
  repeated double one_way_travel_time = 3; 
  optional RangingType type = 4;
  optional ClockMode receiver_clk_mode = 5 [default = UNKNOWN];
  optional ClockMode sender_clk_mode = 6 [default = UNKNOWN];
}

message ModemRangingRequest
{
  optional ModemMsgBase base = 1;
  optional RangingType type = 2;

  // meters, not used if type == MODEM_RANGING
  optional uint32 max_range = 3 [default = 1000]; 
  
  // LSB->MSB is LBL beacons 1,2,3,... true is enabled, false is disabled
  // enable four beacons is b1111 == d15 
  optional uint32 enable_beacons = 4 [default = 15];
}
