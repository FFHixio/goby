import "goby/protobuf/queue.proto";

package goby.acomms.protobuf;

// shared for all messages
message ModemMsgBase
{
  optional int32 src = 1 [default = 0]; //  0 (BROADCAST), 1-31, 
  optional int32 dest = 2 [default = 0]; //  0 (BROADCAST), 1-31, -1 (QUERY_DESTINATION_ID)
  optional string time = 3; // UTC time output from operator<< of boost::posix_time::ptime: e.g. "2002-Jan-01 14:23:11"
  enum TimeSource { MODEM_TIME = 1; GOBY_TIME = 2; } 
  optional TimeSource time_source = 5 [default = GOBY_TIME]; // source of the timestamp given  
  optional uint32 rate = 6 [default = 0]; // 0 (lowest) - 5 (highest)
  optional string raw = 7; // "$CARXD,..."
  optional string description = 8; // "Incoming hexadecimal data"
}


// initiate transmission
message ModemDataInit
{
  optional ModemMsgBase base = 1;
  optional uint32 num_frames = 2 [default = 1]; // set by the modem driver for the given rate
  repeated ModemDataTransmission frame = 3; // if omitted, you will be queried for data on signal_data_request. You can also set some frames here and the rest will be filled by signalling a data request
  
  // 1000-1099 taken by MMDriver
  extensions 1000 to max;
}


// data 
message ModemDataTransmission
{
  optional ModemMsgBase base = 1;
  optional bool ack_requested = 2 [default = true]; // acoustic acknowledgment requested
  //  optional uint32 max_bytes = 3;
  optional bytes data = 4;
  optional uint32 frame = 5 [default = 0];  // frame number if the modem supports multiple frames per packet
  optional uint32 dccl_id = 6;
  
  // 1000-1099 taken by MMDriver
  extensions 1000 to max;
}

message ModemDataAck
{
  optional ModemMsgBase base = 1;
  optional uint32 frame = 2 [default = 0]; // provided by libmodemdriver
}

message ModemDataRequest
{
  optional ModemMsgBase base = 1;
  optional uint32 max_bytes = 2; // omitted means no maximum
  optional uint32 frame = 3 [default = 0]; 

  // 1000-1099 taken by MMDriver
  extensions 1000 to max;
}

enum ClockMode
{
  NO_SYNC_TO_PPS_AND_CCCLK_BAD = 0;
  NO_SYNC_TO_PPS_AND_CCCLK_GOOD = 1;
  SYNC_TO_PPS_AND_CCCLK_BAD = 2;
  SYNC_TO_PPS_AND_CCCLK_GOOD = 3;
}

// ranging
enum RangingType
{

  // modem 1 interrogates modem 2; modem 2 replies and modem 1 computes one way travel time
  MODEM_TWO_WAY_PING = 1; 

  // modems 1 and 2 have synchronous clocks. modem 2 sends to modem 1 at agreed upon time
  // and modem 1 computes one way travel time
  MODEM_ONE_WAY_SYNCHRONOUS = 2;

  // modem 1 pings a REMUS network of long baseline (LBL) beacons
  REMUS_LBL_RANGING = 3;

  // modem 1 pings up to four transponders
  NARROWBAND_LBL_RANGING = 4;
}

message ModemRangingReply
{
  optional ModemMsgBase base = 1;
  // seconds
  repeated double one_way_travel_time = 3;
  enum OWTTAmbiguity
  {
    OWTT_EXACT = 1; // one_way_travel_time reported is correct and known
    OWTT_SECOND_AMBIGUOUS = 2; // one way travel time fractional second is correct, but second is unknown
  }
  optional OWTTAmbiguity ambiguity = 4 [default = OWTT_EXACT];
  optional RangingType type = 5;
  optional ClockMode receiver_clk_mode = 6 [default = NO_SYNC_TO_PPS_AND_CCCLK_BAD];
  optional ClockMode sender_clk_mode = 7 [default = NO_SYNC_TO_PPS_AND_CCCLK_BAD];
}

message ModemRangingRequest
{
  optional ModemMsgBase base = 1;
  optional RangingType type = 2;

  // meters, used if type == REMUS_LBL_RANGING || type == NARROWBAND_LBL_RANGING
  optional uint32 lbl_max_range = 3 [default = 1000]; 
}
