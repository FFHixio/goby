package goby.acomms.protobuf;


// shared for all messages
message ModemMsgBase
{
  optional int32 src = 1 [default = 0]; //  0 (BROADCAST), 1-31, 
  optional int32 dest = 2 [default = 0]; //  0 (BROADCAST), 1-31, -1 (QUERY_DESTINATION_ID)
  optional string time = 3; // UTC time output from operator<< of boost::posix_time::ptime: e.g. "2002-Jan-01 14:23:11"
  enum TimeSource { MODEM_TIME = 1; GOBY_TIME = 2; } 
  optional TimeSource time_source = 5 [default = GOBY_TIME]; // source of the timestamp given  
  optional int32 rate = 6 [default = 0]; // 0 (lowest) - 5 (highest), -1 (QUERY_RATE)

  // 1000-1099 taken by MMDriver
  extensions 1000 to max;
}


message ModemTransmission
{
  optional ModemMsgBase base = 1;
 
  enum TransmissionType
  {
    // General (DriverBase) types
    DATA = 1;

    // 1000-1099 taken by MMDriver - fields used by these types are given as MicroModem Extensions
    // see acomms_mm_driver.proto
    MICROMODEM_TWO_WAY_PING = 1000;   // modem 1 interrogates modem 2; modem 2 replies and modem 1 computes one way travel time: $CCMPC
    MICROMODEM_REMUS_LBL_RANGING = 1001;     // modem 1 pings a REMUS network of long baseline (LBL) beacons: $CCPDT
    MICROMODEM_NARROWBAND_LBL_RANGING = 1002;    // modem 1 pings up to four transponders: $CCPNT
    MICROMODEM_MINI_DATA = 1003; // 13 bits (represented as a 1 frame, 2 byte data transmission where data is AND'd with 0x1ff) mini data transmission
  }

  optional TransmissionType type = 2 [default = DATA];
  
  // for type == DATA
  optional uint32 rate = 10 [default = 0]; // 0 (lowest) - 5 (highest)
  optional uint32 num_frames = 11 [default = 1]; // set by the modem driver for the given rate
  optional uint32 max_frame_bytes = 12; // set by the modem driver for the given rate, omitted means no maximum
  repeated ModemDataTransmission frame = 13; // if omitted, you will be queried for data on signal_data_request. You can also set some frames here and the rest will be filled by signalling a data request

  optional uint32 slot_seconds = 20; // length of slot (in seconds) if this transmission is part of a TDMA cycle
  
  // 1000-1099 taken by MMDriver
  extensions 1000 to max;
}

// for type == DATA transmissions
message ModemDataTransmission
{
  optional ModemMsgBase base = 1;

  optional bytes data = 10;
  optional bool ack_requested = 11 [default = true]; // acoustic acknowledgment requested
  optional uint32 frame = 12 [default = 0];  // frame number if the modem supports multiple frames per packet
  
  // 1000-1099 taken by MMDriver
  extensions 1000 to max;
}

message ModemDataAck
{
  optional ModemMsgBase base = 1;
  optional uint32 frame = 2 [default = 0]; // provided by libmodemdriver

  // 1000-1099 taken by MMDriver
  extensions 1000 to max;
}

message ModemRaw
{
  required string raw = 7; // "$CARXD,..."
  optional string description = 8; // "Incoming hexadecimal data"
}
