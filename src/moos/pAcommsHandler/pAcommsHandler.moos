modem_id = 1    

ProcessConfig = pAcommsHandler
{
  // available to all moos processes.
  AppTick    = 10
  CommsTick  = 10
  
  // verbose, terse, quiet
  verbosity = verbose

  //////////////////////
  // MAC (must be using internal driver)
  //////////////////////
  mac = slotted // or polled or none

  // for slotted
  slot_time = 15 // seconds for the width of each slot
  rate = 0    // modem rate (0, 2, 3, 5 or auto [not implemented])

  // for polled
  // initializer.string = ACOMMS_POLLER_UPDATE = update_type=ADD,poll_type1=data,poll_from_id1=1,poll_to_id1=0,poll_rate1=0,poll_wait1=15
  // initializer.string = ACOMMS_POLLER_UPDATE = update_type=ADD,poll_type1=data,poll_from_id1=2,poll_to_id1=0,poll_rate1=0,poll_wait1=15

  //////////////////////
  // time sync (not implemented)
  //////////////////////
  //  time_sync = true // do automatic "ntp-like" sync of clocks - requires permission to call settimeofday()
  // analogous to ntp numbers
  // set to none or empty if this machine does not have any external clock sync
  // eventually this will be incorporated with ntp
  // low stratum numbers will be used to send clock sync messages
  //  stratum = 1

  //////////////////////
  // Driver configuration
  //////////////////////
  serial_port = /dev/ttyS0
  baud = 19200  

  // set all CFG values to factory defaults at the start before sending our CFG values
  // true is the default

  cfg_to_defaults = true

  // modem CFG values
  cfg = src,1
  cfg = snr,1
  cfg = rev,0

  //////////////////////
  // Queuing configuration
  //////////////////////
  
  // send = DestID, VarName, VariableID, [Ack], [BlackoutTime], [MaxQueue], [NewestFirst], [Priority], [Priority Time Constant]
  // defaults are send = mandatory,mandatory,mandatory,0,0,0,0,0,0,(blank)
  // for all outgoing messages
  //     VarName - local variable to subscribe to
  //     VariableID - 4 bit number (0 - 15) to allow the receiver to publish the variable in a specific remote variable (this number must match receiver's 'receive'
  //                VariableID).
  //     Ack - 0: no ack, 1: request acknowledgement (if no ack received, message will be queued to send again)
  //     BlackoutTime - do not send from this variable more than once per this number of seconds (default 0).
  //     MaxQueue - max number of messages in the queue before no more are added (newest first deletes oldest)
  //     NewestFirst - 0 (default): FIFO stack (messages sent in order received), 1: FILO stack (newest messages sent first)
  //     Priority - highest priority number sent first (default 0). equal priority messages interleaved in queue.
  //     Dynamic Priority Time Constant:
         // p = p' * exp(t-t'/T) where
         // p = calculated priority (used when figuring messages)
         // p' = priority set in previous parameter
         // t = current time
         // t'= last send time
         // T = dynamic priority time constant (what you're setting here)
         //     0 is a special case that means do not use dynamic priorities (T = infinity)

  // send = VarName,
                             //     VariableID 
                             //         [Ack]
                             //             [BlackoutTime]
                             //                 [MaxQueue] 
                             //                      [NewestFirst]
                             //                          [Priority]
                             //                               [Priority Time Constant]
  send = OUT_CTD_HEX_30B,           1,  0,  0,  100, 1,  0.3, 0 

  // send_CCL all parameters same EXCEPT variable ID should be the CCL header (in hex)
  send_CCL = OUT_DEPLOY_HEX_32B,    1a, 1,  0,  1,   1,  10,  120
  send_CCL = OUT_PROSECUTE_HEX_32B, 1a, 1,  0,  1,   1,  10,  120

  send_CCL = OUT_STATUS_HEX_32B,    1b, 0,  0,  1,   1,  1,   120
  send_CCL = OUT_CONTACT_HEX_32B,   1b, 0,  0,  1,   1,  2,   120
  send_CCL = OUT_TRACK_HEX_32B,     1b, 0,  0,  1,   1,  4,   120

  // receive = VarName, VariableID
  receive = IN_CTD_HEX_30B, 1

  // receive = VarName, CCL ID
  receive_CCL = IN_PLUS_COMMANDS_HEX_32B, 1a
  receive_CCL = IN_PLUS_MESSAGES_HEX_32B, 1b

  //////////////////////
  // DCCL Codec configuration
  //////////////////////
  
  // or you could use pGeneralCodec if you set these to "false"
  // default (for legacy support) is false for both
  encode = true
  decode = true

  //////////////////////
  // XML files (used for both Queuing and DCCL encoding)
  //////////////////////
  
  message_file = ../../../data/acomms/acoustic_moospoke.xml

  // manipulators go between "message_file = " and "somexml.xml". comma separate multiple manipulators
  // allowed manipulators:
     // no_encode - do not encode this message
     // no_decode - do not decode this message
     // no_queue  - do not queue this message
     // loopback - decode this message internally immediately following encode (used to command youself)
     // on_demand - encode immediately upon a data request command (use for time sensitive messages like STATUS)
     // tcp_share - send any messages received of this type onto the given clients
  // encodes on demand, always assuming one is available in the queue
  message_file = on_demand = ../../../data/acomms/simple_status.xml
  message_file = loopback,no_queue = ../../../data/acomms/simple_deploy.xml
 

  //////////////////////
  // TCP share
  //////////////////////
  tcp_share_enable = true
  tcp_share_port = 11000
  tcp_share_to_ip = 192.168.1.12:12045
  tcp_share_to_ip = 192.168.1.15

  //////////////////////
  // Misc
  //////////////////////

  // initialize variable at the top of the moos file  
  global_initializer.double = LAT_ORIGIN = LatOrigin
  global_initializer.double = LONG_ORIGIN = LongOrigin
  global_initializer.string = MODEM_ID_PATH = modem_id_lookup_path

  // initialize variable here
  initializer.string = VEHICLE_NAME = unicorn
  initializer.string = VEHICLE_TYPE = auv
}
