// copyright 2009 t. schneider tes@mit.edu
// 
// goby software and documentation is distributed under the GNU General
// Public License.
//
// You should have received a copy of the GNU General Public License
// along with this software (see goby/COPYING).  If not, see <http://www.gnu.org/licenses/>.

/*! \page acomms goby-acomms: Overview of Acoustic Communications Libraries

Table of Contents for \ref acomms.

<ul>
<li> \ref acomms_quick
<li> \ref acomms_overview
<ul>
<li> \ref analogy
<li> \ref acomms_slow
<li> \ref packing_efficiency
<li> \ref why_prioritize
<li> \ref acomms_overview_uml
</ul>
<li> \ref dccl
<li> \ref queue
<li> \ref driver
<li> \ref amac
</ul>

\section acomms_quick Quick Start

To get started using the goby-acomms libraries as quickly as possible:

<ol>
  <li> If you haven't yet, follow instructions on \ref install</li>
  <li> Identify which components you need:</li>
  <ul>
    <li>Encoding and decoding from C++ types to bit-packed messages: \ref dccl</li>
    <li>Queuing of DCCL and CCL messages with priority based message selection: \ref queue</li>
    <li>A driver for interacting with the acoustic %modem firmware. Presently the WHOI Micro-Modem <http://acomms.whoi.edu/> is supported: \ref driver</li>
    <li>Time division multiple access (TDMA) medium access control (MAC): \ref amac</li>
  </ul> 
  <li> Look at the "simple" code examples that accompany each library (\ref libdccl/examples/dccl_simple/dccl_simple.cpp "dccl_simple.cpp", \ref libqueue/examples/queue_simple/queue_simple.cpp "queue_simple.cpp", \ref libmodemdriver/examples/driver_simple/driver_simple.cpp "driver_simple.cpp",  \ref libamac/examples/amac_simple/amac_simple.cpp "amac_simple.cpp"). Then look at the example that uses all the libraries together: \ref acomms/examples/chat/chat.cpp "chat.cpp".  The full list of examples is given in \ref OSI_table "this table". </li>
  <li> Refer to the rest of the documentation as needed.</li>
</ol>


Please visit <https://answers.launchpad.net/goby> with any questions.

    \section acomms_overview Overview
 
    \subsection analogy Analogy to established networking systems
To start on some (hopefully) common ground, let's begin with an analogy to Open Systems Initiative (OSI) networking layers in this \ref OSI_table "table". For a complete description of the OSI layers see <http://www.itu.int/rec/T-REC-X.200-199407-I/en>.

\anchor OSI_table
<table>
  <tr>
    <td><strong>OSI Layer</strong></td>
    <td><strong>Goby library</strong></td>
    <td><strong>API class</strong></td>
    <td><strong>Example(s)</strong></td>
  </tr>
  <tr>
    <td>Application</td>
    <td>Not yet part of Goby</td>
    <td></td>
    <td>MOOS Application: pAcommsHandler</td>
  </tr>
  <tr>
    <td>Presentation</td>
    <td>\ref dccl</td>
    <td>dccl::DCCLCodec</td>
    <td>
      \ref libdccl/examples/dccl_simple/dccl_simple.cpp "dccl_simple.cpp" <br/>
      \ref libdccl/examples/two_message/two_message.cpp "two_message.cpp" <br/>
      \ref libdccl/examples/plusnet/plusnet.cpp "plusnet.cpp" <br/>
      \ref libdccl/examples/test/test.cpp "test.cpp" <br/>
      \ref acomms/examples/chat/chat.cpp "chat.cpp" <br/>
    </td>
  </tr>
  <tr>
    <td>Session</td>
    <td>Not used, sessions are established passively.</td>
    <td></td>
    <td></td>
  <tr>
    <td>Transport</td>
    <td>\ref queue</td>
    <td>queue::QueueManager</td>
    <td>
      \ref libqueue/examples/queue_simple/queue_simple.cpp "queue_simple.cpp" <br/>
      \ref acomms/examples/chat/chat.cpp "chat.cpp" <br/>
    </td>
  </tr>    
  <tr>
    <td>Network</td>
    <td>Does not yet exist. All transmissions are considered single hop, currently. Addressing routing over multiple hops is an open and pressing research problem.</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Data Link</td>
    <td>\ref driver</td>
    <td>classes derived from modem::DriverBase; e.g. micromodem::MMDriver</td>
    <td>
      \ref libmodemdriver/examples/driver_simple/driver_simple.cpp "driver_simple.cpp" <br/>
      \ref acomms/examples/chat/chat.cpp "chat.cpp" <br/>
    </td>
  </tr>
  <tr>
    <td></td>
    <td>\ref amac</td>
    <td>amac::MACManager</td>
    <td>
      \ref libamac/examples/amac_simple/amac_simple.cpp "amac_simple.cpp" <br/>
      \ref acomms/examples/chat/chat.cpp "chat.cpp" <br/>
    </td>
  </tr>
  <tr>
    <td>Physical</td>
    <td>Not part of Goby</td>
    <td></td>
    <td>Modem Firmware, e.g. WHOI Micro-Modem Firmware (NMEA 0183 on RS-232) (see <a href="http://acomms.whoi.edu/documents/uModem\%20Software\%20Interface\%20Guide.pdf">Interface Guide</a>)</td>
  </tr>
</table>

\subsection acomms_slow Acoustic Communications are slow
Do not take the previous analogy too literally; some things we are doing here for acoustic communications (hereafter, acomms) are unconventional from the approach of networking on electromagnetic carriers (hereafter, EM networking). The difference is a vast spread in the expected throughput of a standard internet hardware carrier and acoustic communications. For example, an optical fiber can put through greater than 10 Tbps over greater than 100 km, whereas the WHOI acoustic Micro-Modem can (at best) do 5000 bps over several km. This is a difference of thirteen orders of magnitude for the bit-rate distance product!

\subsection packing_efficiency Efficiency to make messages small is good
Extremely low throughput means that essentially every efficiency in bit packing messages to the smallest size possible is desirable. The traditional approach of layering (e.g. TCP/IP) creates inefficiencies as each layer wraps the message of the higher layer with its own header. See RFC3439 section 3 ("Layering Considered Harmful") for an interesting discussion of this issue <http://tools.ietf.org/html/rfc3439#page-7>. Thus, the "layers" of goby-acomms are more tightly interrelated than TCP/IP, for example. Higher layers depend on lower layers to carry out functions such as error checking and do not replicate this functionality. 

\subsection why_prioritize Total throughput unrealistic: prioritize data
The second major difference stemming from this bandwidth constraint is that <em> total throughput is often an unrealistic goal</em>. The quality of the acoustic channel varies widely from place to place, and even from hour to hour as changes in the sea affect propagation of sound. This means that it is also difficult to predict what one's throughput will be at any given time. These two considerations manifest themselves in the goby-acomms design as a priority based queueing system for the transport layer. Messages are placed in different queues based on their priority (which is determined by the designer of the message). This means that 
<ul>
  <li>the channel is always utilized (low priority data are sent when the channel quality is high)
  <li>important messages are not swamped by low priority data
</ul>

In contrast, TCP/IP considers all packets equally. Packets made from a spam email are given the same consideration as a high priority email from the President. This is a tradeoff in efficiency versus simplicity that makes sense for EM networking, but does not for acoustic communications. 

\subsection simplicity Despite all this, simplicity is good
The "law of diminishing returns" means that at some point, if we try to optimize excessively, we will end up making the system more complex without substantial gain. Thus, goby-acomms makes some concessions for the sake of simplicity:

<ul>
  <li> Numerical message fields are bounded by powers of 10, rather than 2. Humans deal much better with decimal than binary.
  <li> User data splitting (and subsequent stitching) is not done. This is a key component of TCP/IP, but with the number of dropped packets one can expect with acomms, at the moment this does not seem like a good idea. The user is expected to provide data that is smaller or equal to the packet size of the physical layer (e.g. 32 - 256 bytes for the WHOI Micro-Modem). 
</ul>

\subsection acomms_overview_uml Component model

A relatively simple component model for the goby-acomms libraries showing the interface classes:
\image html goby-acomms-overview.png
\image latex goby-acomms-overview.eps "Basic overview of goby-acomms libraries."

For a more detailed model, see the \ref acomms_uml section.

\section dccl libdccl: Encoding and decoding

Dynamic Compact Control Language (DCCL) provides a structure for defining messages to be sent through an acoustic %modem. The messages are configured in XML and are intended to be easily reconfigurable, unlike the original CCL framework used in the REMUS vehicles and others (for information on CCL, see <http://acomms.whoi.edu/ccl/>. DCCL can operate within a CCL network, as the most significant byte (or CCL ID) is 0x20. 

DCCL messages are packed based on boundaries determined with knowledge of the XML file. They are not self-describing as this would be prohibitively expensive in terms of data use. Thus, the sender and receiver must have a copy of the same XML file for decoding a given message. Also, each message is defined by an ID that must be unique with a network. 

Table of Contents for libdccl:
<ul>
<li> \ref dccl_designing
<li> \ref dccl_tags
<li> \ref dccl_codec
<li> \ref dccl_how
<li> \ref dccl_tags_details
</ul>

\section queue libqueue: Priority based message queuing

The goby-acomms queuing library (libqueue) interacts with both the application level process that handles decoding (either through libdccl or other CCL codecs) and the %modem driver process that talks directly to the %modem.

On the application side, libqueue provides the ability for the application level process to push (CCL or DCCL encoded) messages to various queues and receive messages from a remote sender that correspond to messages in the same %queue (e.g. you have a %queue for STATUS_MESSAGE that you can push messages to you and also receive other STATUS_MESSAGEs on). The push feature is called by the application level process and received messages are passed as a callback upon receipt. 

On the driver side, libqueue provides the %modem driver with data upon request. It chooses the data to send based on dynamic priorities (and several other configuration parameters). It will also pack several messages from the user into a single frame from the %modem to fully utilize space (e.g. if the %modem frame is 32 bytes and the user's data are in 16 byte DCCL messages, libqueue will pack two user frames for each %modem frame). This packing and unpacking is transparent to the application side user. Note, however, that libqueue will <em>not</em> split a user's data into frames (like TCP/IP). If this functionality is desired, it must be provided at the application layer. Acoustic communications is too unpredictable to reliably stitch together frames.

Table of Contents for libqueue:
<ul>
<li> \ref queue_priority
<li> \ref queue_tags
<li> \ref queue_manager
<li> \ref queue_tags_details
</ul>

\section driver libmodemdriver: Modem driver

The goby-acomms Modem driver library (libmodemdriver) provides an interface from the rest of goby-acomms to the acoustic %modem firmware. While currently the only driver available is for the WHOI Micro-Modem, this library is written in such a way that drivers for any acoustic %modem that interfaces over a serial connection and can provide (or provide abstractions for) sending data directly to another %modem on the link should be able to be written. Any one who is interested in writing a %modem driver for another acoustic %modem should get in touch with the goby project <https://launchpad.net/goby> and see \ref acomms_writedriver.

Table of Contents for libmodemdriver:
<ul>
<li> \ref acomms_driverbase
<li> \ref acomms_mmdriver
<li> \ref acomms_writedriver
</ul>

\section amac libamac: Medium Access Control (MAC)

The goby-acomms MAC library (libamac) handles access to the shared medium, in our case the acoustic channel. We assume that we have a single band for transmission so that if vehicles transmit simultaneously, collisions will occur between messaging. Therefore, we use time division multiple access (TDMA) schemes, or "slotting". we employ Networks with multiple frequency bands will have to employ a different MAC scheme or augment libamac for the frequency division multiple access (FDMA) scenario. The default TDMA scheme used also includes basic peer discovery and subsequent expiry of peers after a long time of silence.

For legacy support and scenarios where fine control is needed, "polling" is also provided. This is a TDMA enforced by a central computer (the "poller"). The "poller" sends a request for data from a list of nodes in sequential order. The advantage of polling is that synchronous clocks are not needed and the MAC scheme can be changed on short notice by the topside operator.

Table of Contents for libamac:
<ul>
<li> \ref amac_schemes
<li> \ref amac_manager
</ul>

\section  acomms_uml UML models

Model that describes the static structure of goby-acomms as a whole:

\image html goby-acomms-detailed-overview.png
\image latex goby-acomms-detailed-overview.eps "UML Model that shows detailed overview of class interfaces and their connections when using all the goby-acomms libraries together. Note that is possible to replace any of the libraries as long as the user handles the nessary callbacks (e.g. to replace libqueue you need functions to handle the data request, acknowledgement, and receive callbacks from libmodemdriver)." width=\textwidth

Model that gives the sequence for sending a message with goby-acomms:

\image html goby-acomms-send-message-sequence.png
\image latex goby-acomms-send-message-sequence.eps "UML model that gives the sequence of calls required in sending a message using goby-acomms. The WHOI Micro-Modem is used as example firmware but the specific libmodemdriver-firmware interaction will depend on the acoustic modem used." width=\textwidth

Model that shows the commands needed to start and keep goby-acomms running:

\image html goby-acomms-background-sequence.png
\image latex goby-acomms-background-sequence.eps "UML model that illustrates the set of commands needed to start up goby-acomms and keep it running." width=\textwidth


*/
